
- *디자인 패턴* : 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법.
	- 목적은 설계를 재사용하는 것이다.
- *프레임 워크* : 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
	- 목적은 설계와 코드를 함께 재사용하기 위한것이다.

# 🦀 디자인 패턴과 설계 재사용

## 소프트웨어 패턴
- 패턴의 핵심적인 특징
	- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
	- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다.
	- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
	- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

> 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.

- 패턴으로 인정하기 위한 조건 3의 규칙
	- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는점이다.
	- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름' 이다.
	- 패턴은 홀로 존재하지 않는다.


## 패턴과 책임-주도 설계
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
- 패턴의 구성 요소는 클래스가 아니라 *역할* 이다.
- 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

> 디자인 패턴 예시

- `STRATEGY` 패턴 : 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.
- `BRIDGE` 패턴 : 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
- `OBSERVER` 패턴 : 유연한 통지 메커니즘을 구축하기 위해 객체간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.

> 8장의 중복 할인 설계의 기본 구조는 `COMPOSITE` 패턴을 따른다.
## 캡슐화와 디자인 패턴
> 영화 예매 시스템에서 사용한 설계는 `STRATEGY` 패턴을 적용한 예이다.

- `STRATEGY` 패턴 : 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.(합성)
- `TEMPLATEMETHOD` 패턴 :
	- 알고리즘을 캡슐화하기 위해 상속 관계를 사용
	- 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화 할 수 있는 디자인 패턴 (상속)
- `DECORATOR` 패턴 :
	- 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴
	- 객체의 행동을 결합하기 위해서 객체 합성을 사용한다.
	- 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할 수 있다.
	- 핸드폰 과금 시스템 설계에 사용.
- `COMPOSITE` 패턴 :
	- 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화 하는 것이 목적이다.
	- 8장의 중복 할인 정책 구조에서 `Movie` 는 자신과 협력해야 하는 `DiscountPolicy` 인스턴스가 단일 객체인지 복합 객체인지를 알 필요가 없다.
	- 협력하는 객체의 수를 변경하더라도 `Movie` 에 형향을 미치지 않는다.
## 패턴은 출발점이다
- 패턴은 출발점이지 목적지가 아니다.
	- 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
	- 패턴을 적용할 때는 항상 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야 한다.
- 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 도 있다.
- 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이고, 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화되어야 한다.

# 🐭 프레임 워크와 코드 재사용

## 코드 재사용 vs 설계 재사용
